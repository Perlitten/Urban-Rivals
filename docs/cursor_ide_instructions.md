# Инструкции по разработке ML-консультанта Urban Rivals в Cursor IDE

## Введение

Это руководство предоставляет пошаговые инструкции для разработки расширения Chrome "ML-консультант для Urban Rivals" с использованием Cursor IDE. Оно основано на ранее созданной документации, охватывающей ключевые функции, архитектуру, UI, технологии, ML-компонент и интеграцию с браузером.

**Цель**: Создать высококачественное, умное и визуально привлекательное расширение Chrome, работающее локально на Windows.

**Предварительные требования**: Установленный Cursor IDE, Node.js (версия 20+), npm/pnpm, Git.

**Структура проекта**: Рекомендуется следующая структура папок:

```
urban-rivals-ml-consultant/
├── docs/                 # Вся проектная документация (md-файлы)
│   ├── core_features.md
│   ├── architecture.md
│   ├── ui_mockups.md
│   ├── technologies.md
│   ├── ml_component.md
│   └── browser_integration.md
├── public/               # Статические файлы (манифест, иконки, HTML)
│   ├── manifest.json
│   ├── popup.html
│   └── icons/
├── src/                  # Исходный код расширения
│   ├── background/       # Фоновый Service Worker
│   │   └── index.ts
│   ├── content/          # Контентные скрипты
│   │   └── index.ts
│   ├── ui/               # Компоненты React UI
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── styles/
│   │   └── App.tsx
│   ├── ml/               # ML-модели и логика
│   │   ├── models/       # Загруженные модели (ONNX/TF.js)
│   │   ├── workers/      # Web Workers для ML
│   │   └── core.ts
│   ├── common/           # Общие утилиты и типы
│   │   └── types.ts
│   └── popup/            # Код для всплывающего окна
│       └── index.tsx
├── models/               # Исходные ML-модели (до конвертации)
├── data/                 # Данные для обучения/тестирования
├── scripts/              # Скрипты сборки, тестирования
├── .gitignore
├── package.json
├── tsconfig.json
├── webpack.config.js
└── README.md
```

## Шаг 1: Настройка проекта

1.  **Создайте папку проекта**: `mkdir urban-rivals-ml-consultant && cd urban-rivals-ml-consultant`
2.  **Инициализируйте Git**: `git init`
3.  **Инициализируйте Node.js проект**: `pnpm init` (или `npm init -y`)
4.  **Установите зависимости**: (См. `technologies.md` для полного списка)
    ```bash
    # Основные зависимости
    pnpm add react react-dom redux react-redux styled-components tensorflowjs-core tensorflowjs-converter tensorflowjs-layers onnxjs dexie immer
    # Зависимости для разработки
    pnpm add -D typescript @types/react @types/react-dom @types/chrome webpack webpack-cli ts-loader css-loader style-loader copy-webpack-plugin html-webpack-plugin @types/styled-components eslint prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react eslint-config-prettier eslint-plugin-prettier
    # Опционально (для CV/OCR)
    # pnpm add @types/opencv.js tesseract.js @types/tesseract.js
    ```
5.  **Настройте TypeScript (`tsconfig.json`)**: Создайте файл `tsconfig.json` с базовыми настройками для React и DOM, включая `jsx: "react"`, `esModuleInterop: true`, `moduleResolution: "node"`.
6.  **Настройте Webpack (`webpack.config.js`)**: Конфигурируйте Webpack для сборки TypeScript, обработки CSS/Styled Components, копирования статических файлов (манифест, иконки, HTML) и создания бандлов для background, content и popup скриптов.
7.  **Настройте ESLint и Prettier**: Создайте файлы конфигурации (`.eslintrc.js`, `.prettierrc.js`) для обеспечения качества и единообразия кода.
8.  **Создайте структуру папок**: Создайте папки `public`, `src`, `docs` и т.д., как описано выше.
9.  **Скопируйте документацию**: Переместите все ранее созданные `.md` файлы в папку `docs/`.
10. **Создайте базовый манифест (`public/manifest.json`)**: Используйте структуру из `browser_integration.md` как основу.
11. **Создайте базовый `popup.html` (`public/popup.html`)**: Простой HTML-файл с корневым элементом для React-приложения popup.

## Шаг 2: Реализация фонового Service Worker (`src/background/`)

1.  **Основной файл (`index.ts`)**: Реализуйте логику Service Worker.
2.  **Управление состоянием**: Используйте Redux или простой объект для хранения состояния. Инициализируйте Dexie.js для работы с IndexedDB.
3.  **Обработчики сообщений**: Настройте `chrome.runtime.onMessage.addListener` для приема сообщений от контентных скриптов и popup.
4.  **Управление Web Workers**: Создавайте и управляйте Web Workers для ML-задач.
5.  **Периодические задачи**: Используйте `chrome.alarms` для запуска регулярных обновлений (рынок, база карт).
6.  **Инициализация**: Настройте `chrome.runtime.onInstalled` для инициализации хранилища и загрузки базовых данных/моделей при первой установке.

## Шаг 3: Реализация контентных скриптов (`src/content/`)

1.  **Основной файл (`index.ts`)**: Точка входа для контентного скрипта.
2.  **Обнаружение страницы**: Определите, на какой странице Urban Rivals находится пользователь (бой, коллекция, рынок).
3.  **Извлечение данных**: Реализуйте функции для парсинга DOM и извлечения игровых данных (см. `browser_integration.md`). Используйте `MutationObserver` для отслеживания изменений.
4.  **Инъекция UI**: Создайте контейнер на странице и смонтируйте в него React-приложение UI (`src/ui/App.tsx`).
5.  **Коммуникация**: Настройте отправку данных в фоновый скрипт (`chrome.runtime.sendMessage`) и прием команд/данных для обновления UI (`chrome.runtime.onMessage`).

## Шаг 4: Реализация пользовательского интерфейса (`src/ui/`)

1.  **Корневой компонент (`App.tsx`)**: Основной компонент, который рендерит различные части UI в зависимости от контекста (боевые подсказки, конструктор колод и т.д.).
2.  **Компоненты**: Разработайте React-компоненты для каждого элемента UI, описанного в `ui_mockups.md` (панель подсказок, конструктор, аналитика, рынок, настройки).
3.  **Стилизация**: Используйте Styled Components для создания стилей, соответствующих макетам и адаптивному дизайну.
4.  **Управление состоянием UI**: Используйте React Hooks (useState, useEffect) и/или Redux для управления локальным состоянием UI и синхронизации с данными из фонового скрипта.
5.  **Взаимодействие**: Реализуйте обработчики событий для кнопок, фильтров и других интерактивных элементов.

## Шаг 5: Реализация ML-компонента (`src/ml/`)

1.  **Web Workers (`src/ml/workers/`)**: Создайте отдельные файлы `.ts` для каждого типа ML-задачи (боевой анализ, анализ колод, рыночный анализ).
    - Внутри Worker: Загрузите необходимые библиотеки (TensorFlow.js/ONNX.js).
    - Настройте `self.onmessage` для приема данных от фонового скрипта.
    - Реализуйте логику загрузки модели и выполнения инференса.
    - Отправляйте результаты обратно через `self.postMessage`.
2.  **Загрузка моделей**: Модели (в формате TF.js JSON или ONNX) должны быть доступны как `web_accessible_resources` в манифесте и загружаться в Worker.
3.  **Логика ядра (`src/ml/core.ts`)**: Может содержать общие функции для предварительной обработки данных перед отправкой в Worker или постобработки результатов.
4.  **Интеграция**: Фоновый скрипт должен вызывать соответствующие Worker-ы при получении запросов от контентных скриптов.

## Шаг 6: Реализация всплывающего окна (`src/popup/`)

1.  **Точка входа (`index.tsx`)**: Монтирует React-приложение в `popup.html`.
2.  **UI Настроек**: Создайте компоненты для отображения и изменения настроек расширения (см. макет в `ui_mockups.md`).
3.  **Коммуникация**: Взаимодействуйте с фоновым скриптом для получения и сохранения настроек (`chrome.runtime.sendMessage`).

## Шаг 7: Тестирование и отладка

1.  **Модульное тестирование**: Используйте Jest для тестирования отдельных функций и модулей (особенно утилит, логики обработки данных).
2.  **Тестирование компонентов**: Используйте React Testing Library для тестирования UI-компонентов.
3.  **Интеграционное тестирование**: Проверяйте взаимодействие между контентными скриптами, фоновым скриптом и UI.
4.  **End-to-End тестирование**: Используйте Cypress или Puppeteer для автоматизации сценариев использования в браузере.
5.  **Отладка в Chrome**: Используйте Chrome DevTools:
    - Для контентных скриптов и UI: Откройте DevTools на странице Urban Rivals.
    - Для фонового Service Worker: Перейдите в `chrome://extensions/`, найдите расширение и нажмите на ссылку "Service Worker".
    - Для Popup: Кликните правой кнопкой мыши по иконке расширения и выберите "Inspect popup".
6.  **Тестирование ML**: Проверяйте точность моделей на тестовых данных и в реальных игровых сценариях.

## Шаг 8: Сборка и локальное развертывание

1.  **Скрипты сборки (`package.json`)**: Добавьте скрипты для разработки (`pnpm run dev` - с watch режимом) и продакшн сборки (`pnpm run build`).
2.  **Запуск сборки**: `pnpm run build` создаст папку `dist` со всеми необходимыми файлами.
3.  **Установка в Chrome (Windows)**:
    - Откройте Chrome и перейдите в `chrome://extensions/`.
    - Включите "Режим разработчика".
    - Нажмите "Загрузить распакованное расширение".
    - Выберите папку `dist`.
4.  **Проверка**: Перейдите на сайт Urban Rivals и убедитесь, что расширение работает корректно.

## Советы для работы в Cursor IDE

- **Используйте AI-чат**: Задавайте вопросы по API Chrome, React, TensorFlow.js, алгоритмам.
- **Генерация кода**: Используйте AI для генерации шаблонного кода (компоненты React, функции обработки данных, конфигурации).
- **Рефакторинг**: Просите AI помочь с рефакторингом и оптимизацией кода.
- **Отладка**: Описывайте ошибки AI и просите предложить возможные решения или шаги для отладки.
- **Работа с документацией**: Используйте функцию `@` для ссылки на файлы документации (`@docs/architecture.md`) при постановке задач AI.

## Следующие шаги

- После завершения разработки и тестирования MVP, следуйте дорожной карте из `ml_component.md` для дальнейшего развития.
- Регулярно обновляйте зависимости.
- Собирайте обратную связь от пользователей для улучшения.

**Важно**: Всегда обращайтесь к официальной документации Chrome Extensions API, React, TensorFlow.js и других используемых библиотек для получения наиболее точной и актуальной информации.
